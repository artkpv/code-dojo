/*\n * Exercise 3-2. Write a function escape(s,t) that converts characters like\n * newline and tab into visible escape sequences like '\n' and '\t' as it copies the\n * string t to s. Use a switch. Write a function for the other direction as\n * well, converting escape sequences into the real characters. \n *\n * Author : Artyom K. <w1ld at inbox dot ru>, July, 2015\n *\n * NEXT: fix bug when while unescaping it does not unescape '\n' sometime\n *\n */\n\n#include <assert.h.>\n#include <stdio.h>\n\n#define MAXLINE 9999\n\nvoid escape(char s[], char t[])\n{\n\tchar c;\n\tint i = 0, j = 0;\n\twhile((c = s[i++]) != '\0')\n\t{\n\t\tswitch(c)\n\t\t{\n//\t\t\tcase ' ':\n//\t\t\t\tt[j++] = '-';\n//\t\t\t\tbreak;\n\t\t\tcase '\t':\n\t\t\t\tassert(i + 2 < MAXLINE);\n\t\t\t\tt[j++] = '\\';\n\t\t\t\tt[j++] = 't';\n\t\t\t\tbreak;\n\t\t\tcase '\n':\n\t\t\t\tassert(i + 2 < MAXLINE);\n\t\t\t\tt[j++] = '\\';\n\t\t\t\tt[j++] = 'n';\n\t\t\t\tbreak;\n\t\t\tcase '\r':\n\t\t\t\tassert(i + 2 < MAXLINE);\n\t\t\t\tt[j++] = '\\';\n\t\t\t\tt[j++] = 'r';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tt[j++] = c;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tt[j++] = '\0';\n}\n\nvoid escape_stdin()\n{\n\tchar c;\n\tchar s[MAXLINE], t[MAXLINE];\n\tint i = 0;\n\twhile((c = getchar()) != EOF)\n\t{\n\t\ts[i++] = c;\n\t\tif(c == '\n')\n\t\t{\n\t\t\t// escape and flush\n\t\t\ts[i++] = '\0';\n\t\t\tescape(s, t);\n\t\t\tprintf(t);\n\t\t\ti = 0;\n\t\t}\n\t}\n}\n\nint isQuotes(char c) \n{\n\treturn c == '"' || c == '\'';\n}\nvoid unescape(char s[], char t[])\n{\n\tint i = 0, j = 0; \n\tchar c;\n\n\t// loop\n\t//   take next char from s\n\twhile((c = s[i++]) != '\0')\n\t{\n\t\tif(isQuotes(c))\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tt[j++] = '1';\n\t\t\t\tt[j++] = c;\n\n\t\t\t\tif(c == '\\') // escape in string or char\n\t\t\t\t{\n\t\t\t\t\tc = s[i++];\n\t\t\t\t\tt[j++] = '2';\n\t\t\t\t\tt[j++] = c;\n\t\t\t\t}\n\n\t\t\t\tc = s[i++];\n\t\t\t} while(c != '\0' && !isQuotes(c));\n\t\t\tt[j++] = '3';\n\t\t\tt[j++] = c;\n//\t\t\tif(c == '\0') break; // TODO refactor to methods as this is bad to break here.\n\t\t}\n\t\telse if(c == '\\') \n\t\t{\n\t//   if char is \\\n\t//     read next char from s\n\t//     if second char is escape\n\t//       put the escaped char into t\n\t//     else\n\t//       put \ and another char into t\n\n\t\t\tchar c1 = s[i++];\t\n\t\t\tswitch(c1)\n\t\t\t{\n\t\t\t\tcase 'n':\n\t\t\t\t\tt[j++] = '\n'; \n\t\t\t\t\tbreak;\n\t\t\t\tcase 'r':\n\t\t\t\t\tt[j++] = '\r'; \n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\n\t\t\t\t\tt[j++] = '\t';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tt[j++] = c;\n\t\t\t\t\tt[j++] = c1;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse \t\t\n\t\t{\n\t\t\tt[j++] = c;\n\t\t}\n\t}\n\tt[j++] = '\0';\n}\n\nvoid unescape_stdin()\n{\n\tchar c;\n\tchar s[MAXLINE], t[MAXLINE];\n\tint i = 0;\n\t\n\t// fill s till '\n' then unescape and flush\n\twhile((c = getchar()) != EOF)\n\t{\n\t\ts[i++] = c;\n\t\tif(i >= 1 && s[i-2] == '\\' && s[i-1] == 'n')\n\t\t{\n\t\t\ts[i++] = '\0';\n\t\t\tunescape(s, t);\n\t\t\tprintf(t);\n\t\t\ti = 0;\n\t\t}\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tint isEscape = -1;\n\tif(argc == 2)\n\t{\n\t\tchar firstArgChar = argv[1][0];\n\t\tif(firstArgChar == 'e')\n\t\t{\n\t\t\tisEscape = 1;\n\t\t}\n\t\telse if(firstArgChar == 'u')\n\t\t{\n\t\t\tisEscape = 0;\n\t\t}\n\t}\n\n\tif(isEscape == -1)\n\t{\n\t\tprintf("Usage:\n  ex_3-2_escape [escape|unescape]\n");\n\t\treturn 0;\n\t}\n\n\tif(isEscape)\tescape_stdin();\n\telse \t\t\tunescape_stdin();\n\treturn 0;\n}\n
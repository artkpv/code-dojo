using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;
using System.Text.RegularExpressions;

public partial class Lottery
	{
		public string[] sortByOdds(string[] rules)
		{
			 SortedList<LG, object> games = new SortedList<LG, object>();
			foreach (string rule in rules)
				games.Add(new LG(rule), null);

			List<string> sortedNames = new List<string>(games.Count);
			foreach (LG game in games.Keys)
				sortedNames.Add(game.Name);
			return sortedNames.ToArray();
		}
			#region Testing code generated by KawigiEdit
	[STAThread]
	public static void Main(string[] args)
	{
		string[] answer, desiredAnswer;
		bool errors = false;
		bool same;
		DateTime time;
		
		time = DateTime.Now;
		answer = new Lottery().sortByOdds(new string[]{"PICK ANY TWO: 10 2 F F","PICK TWO IN ORDER: 10 2 T F","PICK TWO DIFFERENT: 10 2 F T","PICK TWO LIMITED: 10 2 T T"});
		Console.WriteLine("Time: " + (DateTime.Now-time).TotalSeconds + " seconds");
		desiredAnswer = new string[]{ "PICK TWO LIMITED",  "PICK TWO IN ORDER",  "PICK TWO DIFFERENT",  "PICK ANY TWO" };
		Console.WriteLine("Your answer:");
		if (answer.Length > 0)
		{
			Console.Write("\t{ \"" + answer[0] + "\"");
			for (int i=1; i<answer.Length; i++)
				Console.Write(",\n\t  \"" + answer[i] + "\"");
			Console.WriteLine(" }");
		}
		else
			Console.WriteLine("\t{ }");
		Console.WriteLine("Desired answer:");
		if (desiredAnswer.Length > 0)
		{
			Console.Write("\t{ \"" + desiredAnswer[0] + "\"");
			for (int i=1; i<desiredAnswer.Length; i++)
				Console.Write(",\n\t  \"" + desiredAnswer[i] + "\"");
			Console.WriteLine(" }");
		}
		else
			Console.WriteLine("\t{ }");
		same = (desiredAnswer.Length == answer.Length);
		for (int i=0; i<answer.Length && same; i++)
			if (answer[i] != desiredAnswer[i])
				same = false;
		if (!same)
		{
			errors = true;
			Console.WriteLine("DOESN'T MATCH!!!!");
		}
		else
			Console.WriteLine("Match :-)");
		Console.WriteLine();
		time = DateTime.Now;
		answer = new Lottery().sortByOdds(new string[]{"INDIGO: 93 8 T F", "ORANGE: 29 8 F T", "VIOLET: 76 6 F F", "BLUE: 100 8 T T", "RED: 99 8 T T", "GREEN: 78 6 F T", "YELLOW: 75 6 F F"});
		Console.WriteLine("Time: " + (DateTime.Now-time).TotalSeconds + " seconds");
		desiredAnswer = new string[]{ "RED",  "ORANGE",  "YELLOW",  "GREEN",  "BLUE",  "INDIGO",  "VIOLET" };
		Console.WriteLine("Your answer:");
		if (answer.Length > 0)
		{
			Console.Write("\t{ \"" + answer[0] + "\"");
			for (int i=1; i<answer.Length; i++)
				Console.Write(",\n\t  \"" + answer[i] + "\"");
			Console.WriteLine(" }");
		}
		else
			Console.WriteLine("\t{ }");
		Console.WriteLine("Desired answer:");
		if (desiredAnswer.Length > 0)
		{
			Console.Write("\t{ \"" + desiredAnswer[0] + "\"");
			for (int i=1; i<desiredAnswer.Length; i++)
				Console.Write(",\n\t  \"" + desiredAnswer[i] + "\"");
			Console.WriteLine(" }");
		}
		else
			Console.WriteLine("\t{ }");
		same = (desiredAnswer.Length == answer.Length);
		for (int i=0; i<answer.Length && same; i++)
			if (answer[i] != desiredAnswer[i])
				same = false;
		if (!same)
		{
			errors = true;
			Console.WriteLine("DOESN'T MATCH!!!!");
		}
		else
			Console.WriteLine("Match :-)");
		Console.WriteLine();
		time = DateTime.Now;
		answer = new Lottery().sortByOdds(new string[]{});
		Console.WriteLine("Time: " + (DateTime.Now-time).TotalSeconds + " seconds");
		desiredAnswer = new string[]{ };
		Console.WriteLine("Your answer:");
		if (answer.Length > 0)
		{
			Console.Write("\t{ \"" + answer[0] + "\"");
			for (int i=1; i<answer.Length; i++)
				Console.Write(",\n\t  \"" + answer[i] + "\"");
			Console.WriteLine(" }");
		}
		else
			Console.WriteLine("\t{ }");
		Console.WriteLine("Desired answer:");
		if (desiredAnswer.Length > 0)
		{
			Console.Write("\t{ \"" + desiredAnswer[0] + "\"");
			for (int i=1; i<desiredAnswer.Length; i++)
				Console.Write(",\n\t  \"" + desiredAnswer[i] + "\"");
			Console.WriteLine(" }");
		}
		else
			Console.WriteLine("\t{ }");
		same = (desiredAnswer.Length == answer.Length);
		for (int i=0; i<answer.Length && same; i++)
			if (answer[i] != desiredAnswer[i])
				same = false;
		if (!same)
		{
			errors = true;
			Console.WriteLine("DOESN'T MATCH!!!!");
		}
		else
			Console.WriteLine("Match :-)");
		Console.WriteLine();
		
		
		if (errors)
			Console.WriteLine("Some of the test cases had errors :-(");
		else
			Console.WriteLine("You're a stud (at least on the test data)! :-D ");
	}
	#endregion

	}

	public class LG : IComparable<LG>
	{
		private readonly uint m_Blanks;
		private readonly uint m_Choices;
		private readonly bool m_IsSorted;
		private readonly bool m_IsUnique;
		private readonly string m_Name;
		private readonly double m_ProbabilityOfWin;
		private UInt64 m_NumberOfTickets;

		public LG(string rule)
		{
			Regex re = new Regex(@"([\w ]*): (\d+) (\d+) (F|T) (F|T)");
			Match m = re.Match(rule);
			if (!m.Success)
				throw new ArgumentException("rule");
			m_Name = m.Groups[1].Value;
			m_Choices = uint.Parse(m.Groups[2].Value);
			m_Blanks = uint.Parse(m.Groups[3].Value);
			m_IsSorted = (m.Groups[4].Value[0] == 'T');
			m_IsUnique = (m.Groups[5].Value[0] == 'T');

			//Count probability
			if (!m_IsUnique && !m_IsSorted)		//размещения с повторениями
				m_NumberOfTickets = (UInt64)Math.Pow(m_Choices, m_Blanks);
			else if (!m_IsUnique && m_IsSorted)	//сочетания с повторениями
				m_NumberOfTickets = Convert.ToUInt64((M(m_Choices, m_Blanks + m_Choices - 1) / F(m_Blanks)));
			else if (m_IsUnique && !m_IsSorted)	//размещения без повторений
				m_NumberOfTickets = M(m_Choices - m_Blanks + 1, m_Choices);
			else //сочетания без повторений
				m_NumberOfTickets = Convert.ToUInt64(M(m_Choices - m_Blanks + 1, m_Choices) / F(m_Blanks));
			
			m_ProbabilityOfWin = 1.0/m_NumberOfTickets;
			Console.WriteLine(this);
		}

		public override string ToString()
		{
			return string.Format("{0}: Probability:{1}, Number of tickets:{2}", m_Name, m_ProbabilityOfWin, m_NumberOfTickets);
		}

		public string Name
		{
			get { return m_Name; }
		}

		#region IComparable<LG> Members

		public int CompareTo(LG other)
		{
			if (other.m_ProbabilityOfWin == m_ProbabilityOfWin)
				return m_Name.CompareTo(other.m_Name);
			else
				return other.m_ProbabilityOfWin.CompareTo(m_ProbabilityOfWin);
		}

		#endregion

		private static UInt64 F(uint num)
		{
			if(num > 20)
				throw new ArgumentOutOfRangeException("num", "Can't compute factorial for more then 20.");
			if (num == 0 || num == 1)
				return 1;
			UInt64 result = 1;
			for (uint i = 2; i <= num; i++)
				result *= i;
			return result;
		}
		private UInt64 M(uint fromNum, uint toNum)
		{
			UInt64 result = 1;
			for (uint i = fromNum; i <= toNum; i++)
				result *= i;
			return result;
		}
	}



//Powered by [KawigiEdit] 2.0!

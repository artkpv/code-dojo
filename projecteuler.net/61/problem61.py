"""
https://projecteuler.net/problem=61
Cyclical figurate numbers
Problem 61
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:

Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Square	 	P4,n=n2	 	1, 4, 9, 16, 25, ...
Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
This is the only set of 4-digit numbers with this property.
Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

---

Brute-force using 6 loops and permutations:
    - Огромная сложность - O(n^6*n!). Все сочетания, все перестановки. Как оптимизировать?
    count=192858, total=30181294080, 0.0006389984454901146 in 168.91711134138814ss

SOLUTION:

['P3-8256', 'P4-5625', 'P7-2512', 'P8-1281', 'P6-8128', 'P5-2882']
28684

"""


import sys
MAX_RECURSION = 10000
sys.setrecursionlimit(MAX_RECURSION)

def P3(n):
    return n*(n + 1)/2
def P4(n):
    return n**2
def P5(n):
    return n*(3*n - 1)/2
def P6(n):
    return n*(2*n - 1)
def P7(n):
    return n*(5*n - 3)/2
def P8(n):
    return n*(3*n - 2)

class Seq:
    def __init__(self, generator):
        self.f = generator
        self.items = list(self.take_4d(self.f))

        self.starts = {}
        for i in self.items:
            x = str(i)[:2]
            if x in self.starts:
                self.starts[x] += [i]
            else:
                self.starts[x] = [i]

        {str(i)[2:]: i for i in self.items}
        self.size = len(self.items)

    def take_4d(self, seq):
        n = 1
        while True:
            i = int(seq(n))
            l = len(str(i))
            if l > 4:
                break
            if l > 3:
                yield i
            n += 1

    def __iter__(self):
        for i in self.items:
            yield i

    def __str__(self):
        return self.f.__name__

class Node:
    def __init__(self, v, seq):
        self.v = v
        self.seq = seq

    def __hash__(self):
        return hash(self.v) + hash(self.seq)

    def __eq__(self, other):
        return (self.v, self.seq) == (other.v, other.seq)

    def __ne__(self, other):
        # Not strictly necessary, but to avoid having both x==y and x!=y
        # True at the same time
        return not(self == other)

    def __str__(self):
        return '{}-{}'.format(str(self.seq), self.v)

class Graph:  # oriented graph
    def __init__(self, size):
        self.adj = {}  # dict of arrays

    def join(self, v, k):
        if v not in self.adj:
            self.adj[v] = []
        if k not in self.adj[v]:
            self.adj[v] += [k]

    def adj(self, v):
        return self.adj[v]

    def __str__(self):
        s = ''
        for k in self.adj.keys():
            s += str(k) + ': '
            for i in self.adj[k]:
                s += str(i) + ' '
            s += '\n'

        return s

class CycleFinder:
    def __init__(self, graph, path_length):
        self.path_length = path_length
        self.graph = graph
        self.path = []

    def run(self, s):  # source
        if s in self.graph.adj:
            for w in self.graph.adj[s]:
                self.bfs(s, w, [s])

    def bfs(self, t, v, path):
        if v == t and len(path) == self.path_length:  # found
            self.path = path
            return True
        elif v.seq in (i.seq for i in path):  # gets back some how
            return False
        elif v not in self.graph.adj:  # no linked ones
            return False

        for w in self.graph.adj[v]:
            found = self.bfs(t, w, path + [v])
            if found:
                break


# build graph:
seq3 = Seq(P3)
seq4 = Seq(P4)
seq5 = Seq(P5)
seq6 = Seq(P6)
seq7 = Seq(P7)
seq8 = Seq(P8)
sequences = [seq3, seq4, seq5, seq6, seq7, seq8]
size = sum(s.size for s in sequences)
g = Graph(size)
for s in sequences:
    for i in s.items:
        end = str(i)[2:]
        for s2 in sequences:
            if s2 == s:
                continue
            if end in s2.starts:
                for i2 in s2.starts[end]:
                    g.join(Node(i, s), Node(i2, s2))  # create Node?
print(g)

# search paths in graph:
finder = CycleFinder(g, len(sequences))
someseq = seq3  # start with any
for i in someseq.items:
    node = Node(i, someseq)
    finder.run(node)
    if finder.path:
        print([str(i) for i in finder.path])
        print(sum(n.v for n in finder.path))
        exit()

print('end')


